type OrderBook @entity {
  id: Bytes!
  deployer: Bytes!
  address: Bytes!
  "The RainMetaV1 decode information"
  meta: [RainMetaV1!] # Use the CBOR AS library to decode the meta emitted by the OB
}

type RainMetaV1 @entity {
  "Hash of the meta emitted by the contract"
  id: Bytes! # Hash of the meta emitted by the contract. Including the MagicNumber.
  "Original meta bytes emitted from the contract"
  metaBytes: Bytes! # Original meta bytes emitted from the contract
  "The meta content V1 decoded from the meta bytes emitted"
  content: [MetaContentV1!] @derivedFrom(field: "documents")
}

type MetaContentV1 @entity {
  "The hash of the Map Rain Meta document or CBOR Item"
  id: ID! # Hash of the whole stringify data.
  "The payload present on the index 0 of the Rain meta Document"
  payload: String!
  "The magic number that is used to track the payload"
  magicNumber: BigInt!
  "The header name info for Content-Type"
  contentType: String!
  "The header name info for Content-Encoding. It's optional"
  contentEncoding: String
  "The header name info for Content-Language. It's optional"
  contentLanguage: String
  "RainMeta documents bytes that have this content"
  documents: [RainMetaV1!]
}

# Created with the first AddOrder event, then updated on the corresponding AddOrder/RemoveOrder events
type Order @entity {
  "The hash of the order"
  id: ID! # This value is emitted as Uint256, but you should use the hex string representation (it's a hash)
  "The hash of the transaction"
  transactionHash: Bytes!

  "The address that added the order"
  owner: Account!

  "The IInterpreter address that is used to add the order"
  interpreter: Bytes!

  "The IInterpreterStore address that is used to add the order"
  interpreterStore: Bytes!

  "The IExpressionDeployer contract address that is used to add the order"
  expressionDeployer: Bytes!

  "The address to the rain expression for the Order"
  expression: Bytes!

  "Whether the order is active or inactive"
  orderActive: Boolean!

  "Flag that check if there is a handle_IO entrypoint to run. If false the order book MAY skip calling the interpreter to save gas"
  handleIO: Boolean!

  # "The RainMetaV1 decode information Rain `MetaV1` when the order is placed so can be used by offChain processes."
  meta: RainMetaV1

  "validInputs"
  validInputs: [IO!] @derivedFrom(field: "order")

  "validOutputs"
  validOutputs: [IO!] @derivedFrom(field: "order")

  "Timestamp when the order was added"
  timestamp: BigInt!
}

# Created with AddOrder
type IO @entity {
  id: ID! # ID = `order.hash() - IO.token - IO.vaultId`
  token: ERC20!
  decimals: Int!
  vault: Vault!
  order: Order!
}

# Created and updated whenever an AddOrder event occurs
# Created and updated whenever an Deposit event occurs
# Updated whenever an Withdraw event occurs
type Vault @entity {
  id: ID! #{vaultId}-{owner}
  "The owner of this Vault"
  owner: Account!

  "Tokens in this Vault"
  tokenVaults: [TokenVault!] @derivedFrom(field: "vault")

  "Deposits into this Vault"
  deposits: [VaultDeposit!] @derivedFrom(field: "vault") # add whenever a Deposit event occurs for this {vaultId}-{owner}
  "Withdrawals from this Vault"
  withdraws: [VaultWithdraw!] @derivedFrom(field: "vault") # add whenever a Withdraw event occurs for this {vaultId}-{owner}
}

# Created and updated whenever an AddOrder event occurs
# Created and updated whenever an Deposit event occurs
# Updated whenever an Withdraw event occurs
# ALSO created and updated when a pair of Clear/AfterClear events occur
type TokenVault @entity {
  #{vaultId}-{owner}-{token}
  id: ID!

  # From Deposit.sender / Withdraw.sender
  "The owner of this Vault"
  owner: Account!
  "The id of this vault"
  vault: Vault!

  "The token that has a balance for this vault and owner."
  token: ERC20!

  # Add to this value:
  # Deposit.amount when there is a matching Deposit event for {vaultId}-{owner}-{token}
  # OR AfterClear.stateChange.aInput when there is a Clear event that matches {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken}
  # OR AfterClear.stateChange.bInput when there is a Clear event that matches {Clear.b_.inputVault}-{Clear.b_.owner}-{Clear.b_.inputToken}
  # Subtract from this value:
  # Withdraw.amount when there is a matching Withdraw event for {vaultId}-{owner}-{token}
  # updated on every Deposit/Withdraw event that occurs for this {vaultId}-{owner}-{token}
  "The balance of this token, for this vault, for this owner"
  balance: BigInt!

  # Add to array:
  # when {Order.inputVault}-{Order.owner}-{Order.inputToken} match this TokenVault
  # OR when {Order.outputVault}-{Order.owner}-{Order.outputToken} match this TokenVault
  "Orders that reference this vault, owner and token"
  orders: [Order!]

  # Add to array:
  # when {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken} match this TokenVault
  # OR when {Clear.b_.outputVault}-{Clear.b_.owner}-{Clear.b_.outputToken} match this TokenVault
  # "OrderClears that reference this vault, owner and token"
  orderClears: [OrderClear!]
}

# Created for every Deposit event
type VaultDeposit @entity {
  id: Bytes! # use txhash of the event
  "The transaction sender of this deposit"
  sender: Account! # Deposit.sender
  "The token that was deposited"
  token: ERC20! # Deposit.config.token
  "The vaultId that was deposited into"
  vaultId: BigInt! # Deposit.config.vaultId
  "The Vault that was deposited into"
  vault: Vault! # map by {Deposit.config.vaultId}-{sender}
  "The amount that was deposited"
  amount: BigInt! # Deposit.config.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Deposit.config.vaultId}-{Deposit.sender}-{Deposit.config.token}
}

# Created for every Withdraw event
type VaultWithdraw @entity {
  id: Bytes! # use txhash of the event
  "The transaction sender of this withdrawal"
  sender: Account! # Withdrawal.sender
  "The token that was withdrawn"
  token: ERC20! # Withdraw.config.token
  "The vaultId that was withdrawn from"
  vaultId: BigInt! # Withdraw.config.vaultId
  "The Vault that was withdrawn from"
  vault: Vault! # map by {Withdraw.config.vaultId}-{sender}
  "The amount that was requested be withdrawn"
  requestedAmount: BigInt! # Withdraw.config.amount
  "The amount that was withdrawn"
  amount: BigInt! # Withdraw.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Withdraw.config.vaultId}-{Withdraw.sender}-{Withdraw.config.token}
}

type ERC20 @entity {
  id: Bytes! #address of token
  name: String!
  symbol: String!
  totalSupply: BigInt!
  decimals: Int!
}

type Account @entity {
  id: Bytes!
  orders: [Order!] @derivedFrom(field: "owner")
  withdraws: [VaultWithdraw!] @derivedFrom(field: "sender")
  deposits: [VaultDeposit!] @derivedFrom(field: "sender")
  ordersCleared: [OrderClear!] @derivedFrom(field: "clearer")
  bounties: [Bounty!] @derivedFrom(field: "clearer")
  takeOrderEntities: [TakeOrderEntity!] @derivedFrom(field: "sender")
}

# Created for every pair of AfterClear/Clear events
type OrderClear @entity {
  id: ID! # timestamp
  "The sender address who cleared the Orders"
  sender: Account! # Clear.sender
  "The clearer address who cleared this order"
  clearer: Account! # from Clear.sender
  "Order A being cleared"
  orderA: Order! # map by hash(Clear.a_)
  "Order B being cleared"
  orderB: Order! # map by hash(Clear.b_)
  "The owners of the Orders that were cleared [Order A, Order B]"
  owners: [Account!] # [Clear.a_.owner, Clear.b_.owner]
  "The token input index cleared into Order A"
  aInputIOIndex: BigInt!

  "The token output index cleared into Order A"
  aOutputIOIndex: BigInt!

  "The token input index cleared into Order B"
  bInputIOIndex: BigInt!

  "The token output index cleared into Order B"
  bOutputIOIndex: BigInt!

  "The bounty paid when this order was cleared"
  bounty: Bounty! @derivedFrom(field: "orderClear") # map by unique id created - see Bounty entity
  "The state change that occurred because of this Clear"
  stateChange: OrderClearStateChange! @derivedFrom(field: "orderClear") # map by unique id created - see OrderClearStateChange entity
}

# Created when each OrderClear entity is created
type Bounty @entity {
  id: ID! # create a unique ID when OrderClear entity is created
  "The clearer who received this bounty"
  clearer: Account! # from Clear.sender
  "The Clear event that paid this bounty"
  orderClear: OrderClear!

  "The Vault that bounty token A was deposited into"
  bountyVaultA: Vault! # map by {Clear.clearConfig.aliceBountyVaultId}-{Clear.sender}
  "The Vault that bounty token B was deposited into"
  bountyVaultB: Vault! # map by {Clear.clearConfig.bobBountyVaultId}-{Clear.sender}
  # Not Including Tokens , bounty referenced by VaultA And VaultB

  "The A token for the bounty"
  bountyTokenA: ERC20! # Clear.alice.validOutputs[clearConfig.aliceOutputIOIndex].token
  "The B token for the bounty"
  bountyTokenB: ERC20! # Clear.bob.validOutputs[clearConfig.bobOutputIOIndex].token
  "The amount paid for bounty token A"
  bountyAmountA: BigInt # AfterClear.clearStateChange.aliceOutput - AfterClear.clearStateChange.bobInput
  "The amount paid for bounty token B"
  bountyAmountB: BigInt # AfterClear.clearStateChange.bobOutput - AfterClear.clearStateChange.aliceInput
}

# Created for every pair of TakeOrder events
type TakeOrderEntity @entity {
  id: ID! # Hash of ((TakeOrder.config))
  sender: Account!
  order: Order!
  "The input amount from the perspective of sender"
  input: BigInt!
  "The output amount from the perspective of sender"
  output: BigInt!
  "The index of the input token in order to match with the take order output."
  inputIOIndex: BigInt! # index of input token for Input Token Array
  "The index of the output token in `order` to match with the take order input."
  outputIOIndex: BigInt! # index of output token for Output Token Array
  inputToken: ERC20! # TakeOrder.config.order.validInputs[TakeOrder.config.inputIOIndex].token
  outputToken: ERC20! # TakeOrder.config.order.validOutputs[TakeOrder.config.outputIOIndex].token
}

# Create when an OrderClear entity is created
type OrderClearStateChange @entity {
  id: ID! # create a unique ID when OrderClear entity is created
  orderClear: OrderClear!
  aOutput: BigInt! # AfterClear.clearStateChange.aliceOutput
  bOutput: BigInt! # AfterClear.clearStateChange.bobOutput
  aInput: BigInt! # AfterClear.clearStateChange.aliceInput
  bInput: BigInt! # AfterClear.clearStateChange.bobInput
}

type ClearOrderConfig @entity {
  id: ID!
  orderClearId: OrderClear!
}
